{"ast":null,"code":"import { scan, Token, TOKEN_BEGIN_TAG, TOKEN_END_TAG, TOKEN_TEXT } from \"./lexicalAnalyzer\";\n\nvar parseStyledText = function parseStyledText(tokens, startIndex) {\n  var styleName = tokens[startIndex].lexeme;\n  var index = startIndex + 1;\n\n  var _parseMixedText = parseMixedText(tokens, index),\n      mixedText = _parseMixedText.mixedText,\n      length = _parseMixedText.length;\n\n  index += length;\n\n  if (index < tokens.length && tokens[index].type === TOKEN_END_TAG) {\n    if (tokens[index].lexeme && tokens[index].lexeme !== styleName) {\n      console.warn('react-native-styled-text: style name mismatch <' + styleName + '>...</' + tokens[index].lexeme + '>');\n    }\n\n    index++;\n  }\n\n  return {\n    styledText: {\n      styleName: styleName,\n      mixedText: mixedText\n    },\n    length: index - startIndex\n  };\n};\n\nvar parseMixedText = function parseMixedText(tokens, startIndex) {\n  var mixedText = [];\n  var index = startIndex;\n\n  while (index < tokens.length && tokens[index].type !== TOKEN_END_TAG) {\n    var token = tokens[index];\n\n    switch (token.type) {\n      case TOKEN_BEGIN_TAG:\n        {\n          var _parseStyledText = parseStyledText(tokens, index),\n              styledText = _parseStyledText.styledText,\n              length = _parseStyledText.length;\n\n          mixedText.push(styledText);\n          index += length;\n          break;\n        }\n\n      case TOKEN_TEXT:\n        mixedText.push(token.lexeme);\n        index++;\n        break;\n\n      default:\n        console.warn('Unexpected ' + token.type + ': ' + token.lexeme);\n        index++;\n        break;\n    }\n  }\n\n  return {\n    mixedText: mixedText,\n    length: index - startIndex\n  };\n};\n\nexport var parse = function parse(text) {\n  var tokens = scan(text);\n\n  var _parseMixedText2 = parseMixedText(tokens, 0),\n      mixedText = _parseMixedText2.mixedText,\n      length = _parseMixedText2.length;\n\n  if (length < tokens.length) {\n    var unexpectedToken = tokens[length];\n    console.warn('Unexpected ' + unexpectedToken.type + ': ' + unexpectedToken.lexeme);\n  }\n\n  return mixedText;\n};","map":{"version":3,"sources":["/home/mayank/Study/TPE/h1/assist-learning/assist/node_modules/react-native-styled-text/StyledText/parser.js"],"names":["scan","Token","TOKEN_BEGIN_TAG","TOKEN_END_TAG","TOKEN_TEXT","parseStyledText","tokens","startIndex","styleName","lexeme","index","parseMixedText","mixedText","length","type","console","warn","styledText","token","push","parse","text","unexpectedToken"],"mappings":"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","sourcesContent":["import {\n  scan,\n  Token,\n  TOKEN_BEGIN_TAG,\n  TOKEN_END_TAG,\n  TOKEN_TEXT,\n} from './lexicalAnalyzer';\n\n// Syntax:\n// beginStyle ::= <style-name>\n// endStyle   ::= </style-name> | </>\n// plainText  ::= .*\n// styledText ::= beginStyle mixedText [endStyle]\n// mixedText  ::= (plainText | styledText)*\n\nexport type Styled = {\n  styleName: string,\n  mixedText: Mixed,\n};\n\nexport type Mixed = Array<Styled | string>\n\nconst parseStyledText = (tokens: Array<Token>, startIndex: number)\n  : { styledText: Styled, length: number } => {\n  const styleName = tokens[startIndex].lexeme;\n  let index = startIndex + 1;\n  const { mixedText, length } = parseMixedText(tokens, index);\n  index += length;\n  if (index < tokens.length && tokens[index].type === TOKEN_END_TAG) {\n    // Check proper nesting of styles, if style name used on end tag\n    if (tokens[index].lexeme && tokens[index].lexeme !== styleName) {\n      console.warn('react-native-styled-text: style name mismatch <' + styleName + '>...</' + tokens[index].lexeme + '>');\n    }\n    index++;\n  }\n\n  return {\n    styledText: {\n      styleName,\n      mixedText,\n    },\n    length: index - startIndex,\n  };\n};\n\nconst parseMixedText = (tokens: Array<Token>, startIndex: number)\n  : { mixedText: Mixed, length: number } => {\n  const mixedText = [];\n  let index = startIndex;\n  while (index < tokens.length && tokens[index].type !== TOKEN_END_TAG) {\n    const token = tokens[index];\n    switch (token.type) {\n    case TOKEN_BEGIN_TAG: {\n        const { styledText, length } = parseStyledText(tokens, index);\n        mixedText.push(styledText);\n        index += length;\n        break;\n      }\n    case TOKEN_TEXT:\n      mixedText.push(token.lexeme);\n      index++;\n      break;\n    default: \n      console.warn('Unexpected ' + token.type + ': ' + token.lexeme);\n      index++;\n      break;\n    }\n  }\n\n  return {\n    mixedText,\n    length: index - startIndex,\n  };\n};\n\nexport const parse = (text: string): Mixed => {\n  const tokens = scan(text);\n  const { mixedText, length } = parseMixedText(tokens, 0);\n  \n  if (length < tokens.length) {\n    const unexpectedToken = tokens[length];\n    console.warn('Unexpected ' + unexpectedToken.type + ': ' + unexpectedToken.lexeme);\n  }\n\n  return mixedText;\n};\n"]},"metadata":{},"sourceType":"module"}